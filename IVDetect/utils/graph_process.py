# not used anymore
import networkx as nx
import pandas as pd
import torch
from torch_geometric.data import Data
import numpy as np
import vul_model
from utils import lexical_parser
import pygraphviz


# with pygraphviz
def graph_from_dot(_dot):
    try:
        G_non_label = nx.nx_agraph.from_agraph(pygraphviz.AGraph(_dot))
        G_out = nx.relabel_nodes(G_non_label, lambda x: int(x) - 1000100)
        return G_out
    except:
        return ''


# get no2st and reindex
def get_no2st_dict(_No2St):
    _tmp_dict = dict([int(key), value] for key, value in _No2St.items())
    _no_2_st = {}
    for k, d_list in _tmp_dict.items():
        _new_d_list = []
        for d in d_list:
            for key, value in d.items():
                _new_d_list.append(int(key) - 1000100)
        _no_2_st[k] = _new_d_list
    return _no_2_st


# # get no2st and reindex
# def get_no2st_dict(_index, _data_frame: pd.DataFrame):
#     _tmp_dict = dict([int(key), value] for key, value in _data_frame.No2St.values[_index].items())
#     _no_2_st = {}
#     for k, d_list in _tmp_dict.items():
#         _new_d_list = []
#         for d in d_list:
#             for key, value in d.items():
#                 _new_d_list.append(int(key) - 1000099)
#         _no_2_st[k] = _new_d_list
#     return _no_2_st


# extract ast graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def ast_from_cpg(_cpg_graph):
    ast_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "AST" in d['label']]
    ast_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if "AST" in d['label']]
    _ast_graph = _cpg_graph.edge_subgraph(ast_edges).copy()
    for u, v, d in ast_edges_attr:
        _ast_graph.add_edge(u, v, label=d.get('label'))
    return _ast_graph


# extract pdg graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def pdg_from_cpg(_cpg_graph):
    pdg_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "DDG" in d['label'] or "CDG" in d['label']]
    pdg_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if
                      "DDG" in d['label'] or "CDG" in d['label']]
    _pdg_graph = _cpg_graph.edge_subgraph(pdg_edges).copy()
    for u, v, d in pdg_edges_attr:
        _pdg_graph.add_edge(u, v, label=d.get('label'))
    return _pdg_graph


def get_graph_data(_graph, _No2St_dict):
    # _edge_list = get_edge_lists(_graph)
    _edge_list = get_edge_lists_new(_graph, _No2St_dict)
    print(_edge_list)
    _graph_data = generate_big_graph_list(_edge_list)
    return _graph_data


def get_edge_lists_new(_graph, _No2St_dict):
    # print(_No2St_dict)
    # _new_No2St_dict = {}
    # _node_index = 0
    # for key,value in _No2St_dict.items():
    #     _new_No2St_dict[_node_index] = value
    #     _node_index += 1
    _edge_lists = []
    for u, v, d in _graph.edges(data=True):
        for st, nodes in _No2St_dict.items():
            for node in nodes:
                if node == u:
                    out_ = st
                    break
        for st2, nodes in _No2St_dict.items():
            for node in nodes:
                if node == v:
                    in_ = st2
                    break
        if out_ != in_:
            if [out_, in_] not in _edge_lists:
                _edge_lists.append([out_, in_])
    old_graph = nx.Graph()
    for _edge in _edge_lists:
        old_graph.add_edge(_edge[0], _edge[1])
    _reindex_graph = nx.relabel.convert_node_labels_to_integers(old_graph, first_label=0, ordering='default')
    # print(reindex_graph.nodes)
    _reindex_edge_list = []
    for u, v, d in _reindex_graph.edges(data=True):
        _reindex_edge_list.append([u, v])
    return _reindex_edge_list


# input: networkx graph
# output: list of [[node_out,node_in],...]
def get_edge_lists(_graph):
    _edge_lists = []
    for u, v, d in _graph.edges(data=True):
        _edge_lists.append([u, v])
    return _edge_lists


# input: edge_lists (generate from func: get_edge_lists())
# output a graph(torch_geometric.data.Data) object with edge_index
def generate_big_graph_list(_edge_lists):
    # This one is used to generate the overall PDG for a method
    in_ = []
    out_ = []
    for list in _edge_lists:
        in_.append(list[0])
        out_.append(list[1])
    output = torch.tensor([in_, out_],dtype=torch.long)
    # print("edge index",output)
    graph_data = Data(edge_index=torch.tensor(output))
    return graph_data


# input: networkx graph
# output: dict of every node with a list of its directly connected node
# referring as: graph_info for vul_model.generate_graph_feature
def get_graph_info(_graph):
    _graph_info = {}
    for node in list(_graph.nodes):
        # print(node)
        node_info = nx.bfs_tree(_graph, node, reverse=False, depth_limit=1)
        _graph_info[node] = []
        if len(node_info) > 1:
            for n in node_info:
                if n != node:
                    _graph_info[node].append(n)
    return _graph_info


def get_tree_info(_no2st_dict, _ast_graph, _w2v_model):
    _tree_info_list = get_tree_info_list(_no2st_dict, _ast_graph, _w2v_model)
    _tree_info = vul_model.generate_tree_feature(_tree_info_list)
    return _tree_info


# input: no2st_dct, ast graph, w2v embedding model
# output tree_info value for vul_model.generate_tree_feature func
def get_tree_info_list(_no2st_dict, _ast_graph, _w2v_model):
    ast_graph_info = get_graph_info(_ast_graph)
    tree_info_list = []
    for st, ast_nodes in _no2st_dict.items():
        _AST = []
        edge_list = {}
        node_value_list = {}
        for ast_node in ast_nodes:
            if ast_node in _ast_graph.nodes:
                ast_node_code = _ast_graph.nodes[ast_node]['label']
                ast_node_tokens = lexical_parser(ast_node_code.split(',', 1)[1])
                if ast_node_tokens:
                    edge_list[ast_node] = []
                    # print(ast_node_code, ":", ast_node_tokens)
                    # ast_node_tokens = [x for x in ast_node_tokens if x in _w2v_model.wv.key_to_index]
                    list_of_vector = [_w2v_model.wv[i] for i in ast_node_tokens if i in _w2v_model.wv.key_to_index]
                    if not list_of_vector:
                        list_of_vector.append(np.zeros(100))
                    # print("list of v",list_of_vector)
                    # if list_of_vector:
                    arrs = np.array(list_of_vector)
                    arrs = arrs[~np.isnan(arrs).any(axis=1)]
                    mean = np.mean(arrs, axis=0)
                    node_value_list[ast_node] = mean
                    ast_sub_nodes = ast_graph_info.get(ast_node)
                    for ast_sub_node in ast_sub_nodes:
                        ast_sub_node_code = _ast_graph.nodes[ast_sub_node]['label']
                        ast_node_sub_tokens = lexical_parser(ast_sub_node_code.split(',', 1)[1])
                        if ast_node_sub_tokens:
                            edge_list[ast_node].append(ast_sub_node)
                            if ast_sub_node not in ast_nodes:
                                # out of statement node, generate vec here
                                list_of_vector_sub = [_w2v_model.wv[i] for i in ast_node_sub_tokens if
                                                      i in _w2v_model.wv.key_to_index]
                                # if list_of_vector_sub:
                                if not list_of_vector_sub:
                                    list_of_vector_sub.append(np.zeros(100))
                                arrs = np.array(list_of_vector_sub)
                                # print(arrs.shape)
                                arrs = arrs[~np.isnan(arrs).any(axis=1)]
                                # print(arrs.shape)
                                mean = np.mean(arrs, axis=0)
                                node_value_list[ast_sub_node] = mean

        if edge_list and node_value_list:
            # print("for each ast")
            # print("edge_list",edge_list)
            # print("node_value_list")
            # for k,v in node_value_list.items():
            #     print(k,v.shape,end="\t")
            # print()
            _AST.append(edge_list)
            _AST.append(node_value_list)
            tree_info_list.append(_AST)
    return tree_info_list


def get_data(_graph, _cpg_graph, _w2v_model, No2St_dict):
    # _graph_info_new: statement and its connected statement by PDG
    # _statement_value:feature vector of each statement
    _statement_info, _statement_value = get_graph_input_new(_graph, _cpg_graph, _w2v_model, No2St_dict)
    # print("_statement_value")
    # for k,v in _statement_value.items():
    #     print(k,v.shape)
    _data = []
    data_0 = vul_model.generate_graph_feature(_statement_info, _statement_value, steps=1)
    # tensor_data_0 = [torch.from_numpy(item).float() for item in data_0]
    # data_0 = torch.stack(data_0)
    _data.append(data_0)

    data_1 = vul_model.generate_graph_feature(_statement_info, _statement_value, steps=2)
    # tensor_data_1 = [torch.from_numpy(item).float() for item in data_1]
    # data_1 = torch.stack(data_1)
    _data.append(data_1)
    # print("mydata",_data)
    return _data


# input: pdg graph, word to vector model, node to statement dict
# output: statement-connected statement dict, statement feature vec for each statement
def get_graph_input_new(_pdg_graph, _cpg_graph, _w2v_model, No2St_dict):
    # print(No2St_dict)
    _statement_info = {}
    pdg_graph_info = get_graph_info(_pdg_graph)
    for st, st_nodes in No2St_dict.items():
        # print("statement",st)
        _statement_info[st] = []
        for st_node in st_nodes:
            if st_node in _pdg_graph.nodes:
                for sub_node in pdg_graph_info.get(st_node):
                    # print("subnode",sub_node)
                    if sub_node not in st_nodes:
                        for sub_st, sub_st_nodes in No2St_dict.items():
                            if sub_node in sub_st_nodes:
                                if sub_st not in _statement_info[st]:
                                    _statement_info[st].append(sub_st)
    # print(_statement_info)
    _statement_value = {}
    # print("cpg nodes:",_cpg_graph.nodes.data())
    for st, st_nodes in No2St_dict.items():
        # print("statement",st,st_nodes)
        list_of_node_vec = []
        for st_node in st_nodes:
            # print("\t",st_node)
            if st_node in _cpg_graph.nodes:
                st_node_code = _cpg_graph.nodes[st_node]['label']
                # print("\t",st_node_code)
                cpg_node_tokens = lexical_parser(st_node_code.split(',', 1)[1])
                if cpg_node_tokens:
                    list_of_vector = [list(_w2v_model.wv[i]) for i in cpg_node_tokens if
                                      i in _w2v_model.wv.key_to_index]
                    arrs = np.array(list_of_vector)
                    if arrs != []:
                        arrs = arrs[~np.isnan(arrs).any(axis=1)]
                        # this step can also be deleted
                        mean = np.mean(arrs, axis=0)
                        list_of_node_vec.append(mean)
        if list_of_node_vec:
            arrs = np.array(list_of_node_vec)
        # print(arrs)
        else:
            arrs = []
        _statement_value[st] = arrs
    # for k,vs in _statement_value.items():
    #     print(k,vs.shape)
    # # exit()
    return _statement_info, _statement_value


# return [graph info] and [statement value] value for vul_model.generate_graph_feature func
def get_graph_input(_pdg_graph, _w2v_model):
    pdg_graph_info = get_graph_info(_pdg_graph)
    _statement_value = {}
    for pdg_node in pdg_graph_info.keys():
        pdg_node_code = _pdg_graph.nodes[pdg_node]['label']
        pdg_node_tokens = lexical_parser(pdg_node_code.split(',', 1)[1])
        if pdg_node_tokens:
            list_of_vector = [list(_w2v_model.wv[i]) for i in pdg_node_tokens if i in _w2v_model.wv.key_to_index]
            arrs = np.array(list_of_vector)
            arrs = arrs[~np.isnan(arrs).any(axis=1)]
            mean = np.mean(arrs, axis=0)
            _statement_value[pdg_node] = mean
    # some node have no work vector, get rid
    _graph_info_new = {}
    for k, vs in pdg_graph_info.items():
        if k in _statement_value:
            _graph_info_new[k] = []
            for v in vs:
                if v in _statement_value:
                    _graph_info_new[k].append(v)
    return _graph_info_new, _statement_value


def generate_Data_input(_graph_data, _tree_info, _data, _target):
    print(len(_tree_info),len(_data[0]))
    _graph_data.tree_info = _tree_info
    _graph_data.my_data = _data
    _graph_data.y = _target
    _graph_data.num_nodes = len(_data[0])
    return _graph_data
