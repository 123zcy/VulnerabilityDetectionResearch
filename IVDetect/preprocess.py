
import pandas as pd
import pygraphviz
import torch
from gensim.models.word2vec import Word2Vec
from torch_geometric.data import Data, DataLoader
import matplotlib.pyplot as plt
from utils import lexical_parser
import networkx as nx
import numpy as np
import ast
from vul_model import generate_tree_feature, generate_graph_feature
import torch.nn.utils.rnn as rnn_utils
from tqdm import tqdm


# with pygraphviz
def dot_to_graph(_dot):
    try:
        G_non_label = nx.nx_agraph.from_agraph(pygraphviz.AGraph(_dot))
        G_out = nx.relabel_nodes(G_non_label, lambda x: int(x) - 1000100)
        return G_out
    except:
        return ''


# https://stackoverflow.com/questions/3229419/how-to-pretty-print-nested-dictionaries
def pretty(d, indent=0):
    for key, value in d.items():
        print('\t' * indent + str(key))
        if isinstance(value, dict):
            pretty(value, indent + 1)
        else:
            print('\t' * (indent + 1) + str(value))


def get_statement_dict(_No2St):
    if type(_No2St) is not dict:
        return ''
    # pretty(_No2St)
    _st_nodes_dict = {}
    _start_st = 0
    for _key, _nodes in _No2St.items():
        _st_nodes_dict[_start_st] = []
        for _node in _nodes:
            for _id, _code in _node.items():
                # only consider node with more than 1 letter
                if len(_code) > 1:
                    _new_id = int(_id) - 1000100
                    _st_nodes_dict[_start_st].append(_new_id)
        # if no node in statement, ignore it
        if _st_nodes_dict[_start_st]:
            _start_st += 1
        else:
            del _st_nodes_dict[_start_st]
    # pretty(_st_nodes_dict)
    return _st_nodes_dict


def my_draw(_graph):
    nx.draw(_graph, pos=nx.nx_agraph.graphviz_layout(_graph), with_labels=True)
    plt.show()


# extract pdg graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def get_pdg_from_cpg(_cpg_graph):
    pdg_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "DDG" in d['label'] or "CDG" in d['label']]
    pdg_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if
                      "DDG" in d['label'] or "CDG" in d['label']]
    _pdg_graph = _cpg_graph.edge_subgraph(pdg_edges).copy()
    for u, v, d in pdg_edges_attr:
        _pdg_graph.add_edge(u, v, label=d.get('label'))
    return _pdg_graph


# extract cfg graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def get_cfg_from_cfg(_cpg_graph):
    cfg_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "CFG" in d['label']]
    cfg_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if "CFG" in d['label']]
    _cfg_graph = _cpg_graph.edge_subgraph(cfg_edges).copy()
    for u, v, d in cfg_edges_attr:
        _cfg_graph.add_edge(u, v, label=d.get('label'))
    return _cfg_graph


# extract ddg graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def get_ddg_from_ddg(_cpg_graph):
    ddg_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "DDG" in d['label']]
    ddg_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if "DDG" in d['label']]
    _ddg_graph = _cpg_graph.edge_subgraph(ddg_edges).copy()
    for u, v, d in ddg_edges_attr:
        _ddg_graph.add_edge(u, v, label=d.get('label'))
    return _ddg_graph


# extract ast graph from cpg graph
# input: a networkx graph
# output: a networkx graph
def get_ast_from_cpg(_cpg_graph):
    ast_edges = [(u, v, '') for u, v, d in _cpg_graph.edges(data=True) if "AST" in d['label']]
    ast_edges_attr = [(u, v, d) for u, v, d in _cpg_graph.edges(data=True) if "AST" in d['label']]
    _ast_graph = _cpg_graph.edge_subgraph(ast_edges).copy()
    for u, v, d in ast_edges_attr:
        _ast_graph.add_edge(u, v, label=d.get('label'))
    return _ast_graph


def get_edge_index(_St_Node, _PDG_Graph):
    # pretty(_St_Node)
    # my_draw(_PDG_Graph)
    # print(_PDG_Graph.edges)
    in_ = []
    out_ = []
    for u, v, d in _PDG_Graph.edges(data=True):
        # print(u, ">", v, end="\t")
        _new_in, _new_out = None, None
        for _in_st, _in_nodes in _St_Node.items():
            if u in _in_nodes:
                _new_in = _in_st
                # print(u, "in", _in_st, end="\t")
                break
        for _out_st, _out_nodes in _St_Node.items():
            if v in _out_nodes:
                _new_out = _out_st
                # print(v, "in", _out_st, end="\t")
                break
        # print()
        if _new_in != _new_out and _new_in is not None and _new_out is not None:
            # print("add", _new_in, _new_out)
            in_.append(_new_in)
            out_.append(_new_out)
    output = torch.tensor([in_, out_], dtype=torch.long)
    output = torch.unique(output, dim=1)
    if output.nelement() == 0:
        # print("no edge")
        return ''
    graph_data = Data(edge_index=output.detach().clone())
    graph_data.num_nodes = len(_St_Node)
    return graph_data


# input: nx graph, depth
# purpose: get a node's neighbor by using breath first algorithm
def get_node_neighbor(_graph, depth):
    _graph_info = {}
    for node in list(_graph.nodes):
        node_info = nx.bfs_tree(_graph, node, reverse=False, depth_limit=depth)
        _graph_info[node] = []
        if len(node_info) > 1:
            for n in node_info:
                if n != node:
                    _graph_info[node].append(n)
    return _graph_info


def generate_node_feature_vec(_NX_CPG, _w2v_model):
    _node_fea_dict = {}
    # print(_NX_CPG.nodes.data())
    for _node in _NX_CPG.nodes:
        _node_dict = _NX_CPG.nodes[_node]
        if _node_dict.get('label') is None:
            # this node have no label, joern error, fill with 0
            _node_fea_vec = [np.zeros(100)]
        else:
            _node_code = _node_dict.get('label')
            _node_tokens = lexical_parser(_node_code.split(',', 1)[1])
            # if _node_tokens:
            _node_fea_vec = [_w2v_model.wv[i] for i in _node_tokens if i in _w2v_model.wv.key_to_index]
            if not _node_fea_vec:
                _node_fea_vec.append(np.zeros(100))
            # _node_fea_dict[_node] = np.array(_node_fea_vec)
            # continue
        arrs = np.array(_node_fea_vec)
        arrs = arrs[~np.isnan(arrs).any(axis=1)]
        mean = np.mean(arrs, axis=0)
        _node_fea_dict[_node] = mean

    # for k, v in _node_fea_dict.items():
    #     print(k, v.shape)
    return _node_fea_dict


def get_tree_info(_St_Node, _AST_graph, _Node_Fea_Vec):
    tree_info = []
    ast_neighbour = get_node_neighbor(_AST_graph, depth=1)
    for st, nodes in _St_Node.items():
        _AST = []
        _edge_list = {}
        _node_vec_list = {}
        for node in nodes:
            _edge_list[node] = []
            node_feature = _Node_Fea_Vec.get(node)
            if node_feature is not None:
                _node_vec_list[node] = node_feature
                sub_nodes = ast_neighbour.get(node)
                if sub_nodes:
                    for sub_node in sub_nodes:
                        sub_node_feature = _Node_Fea_Vec.get(sub_node)
                        if sub_node_feature is not None:
                            _node_vec_list[sub_node] = sub_node_feature
                            _edge_list[node].append(sub_node)
        #                 else:
        #                     print(sub_node, "sub node fea not in AST")
        #     else:
        #         print(node,"not in AST")
        # if len(_edge_list) == 0:print("empty edge list")
        # if len(_node_vec_list) == 0:print("empty node vec list")
        # print(_edge_list)
        _AST.append(_edge_list)
        # for k, v in _node_vec_list.items():
        #     print(k, v.shape)
        _AST.append(_node_vec_list)
        tree_info.append(_AST)

    try:
        tree_feature = generate_tree_feature(tree_info=tree_info)
        return tree_feature
    except:
        return ''


def get_graph_info(_St_Node, _PDG_graph, _CPG_graph, _Node_Fea_Vec, _code, _No2St):
    # pretty(_No2St)
    _statement_info = {}
    pdg_neighbour = get_node_neighbor(_PDG_graph, depth=1)
    for st, nodes in _St_Node.items():
        _statement_info[st] = []
        for node in nodes:
            if node in _PDG_graph.nodes:
                for sub_node in pdg_neighbour.get(node):
                    if sub_node not in nodes:
                        for sub_st, sub_st_nodes in _St_Node.items():
                            if sub_node in sub_st_nodes:
                                if sub_st not in _statement_info[st]:
                                    _statement_info[st].append(sub_st)
    _statement_value = {}
    for st, nodes in _St_Node.items():
        list_of_node_vec = []
        for node in nodes:
            node_vec = _Node_Fea_Vec.get(node)
            if node_vec is not None:
                list_of_node_vec.append(node_vec)
        if list_of_node_vec is not []:
            arrs = np.array(list_of_node_vec)
        else:
            arrs = []
            # print(_Node_Fea_Vec)
            # print(_CPG_graph.nodes.data())
            # print("statement", st, nodes, " have no feature vec")
            # print(_Node_Fea_Vec.get(13),_Node_Fea_Vec.get(20),_Node_Fea_Vec.get(29))
        _statement_value[st] = arrs
    # for k, vs in _statement_value.items():
    #     print(k, vs.shape)

    graph_info = [generate_graph_feature(_statement_info, _statement_value, steps=1),
                  generate_graph_feature(_statement_info, _statement_value, steps=2)]
    return graph_info


def get_sim_input(graph_data, graph_info, target):
    # print(graph_info[0])
    # graph_info[0] = [torch.mean(i, dim=0) for i in graph_info[0]]
    graph_info[0] = [torch.sum(i, dim=0) for i in graph_info[0]]
    padded = rnn_utils.pad_sequence(graph_info[0], batch_first=True, padding_value=0)
    graph_data.x = padded
    graph_data.y = target
    # print(graph_data)
    return graph_data


def get_input(_graph_data, _graph_info, _tree_info, _target):
    _graph_data.tree_info = _tree_info
    _graph_data.my_data = _graph_info
    _graph_data.y = _target
    return _graph_data


def preprocess(input_graph_file):
    df = pd.read_json(input_graph_file)
    print(df.info())
    df = df[df.No2St != 'No Node']
    df = df[df.CPG != 'No Graph']
    df = df[df.CPG != '']
    df['token'] = df.func.apply(lexical_parser)
    w2v_model = Word2Vec(df.token, min_count=1)
    print(w2v_model)
    # transport dot to networkx graph
    df['NX_CPG'] = df.apply(lambda row: dot_to_graph(row.CPG), axis=1)
    df = df[df.NX_CPG != '']
    # nodes of each statements
    df['St_Node'] = df.apply(lambda row: get_statement_dict(row.No2St), axis=1)
    df = df[df.St_Node != '']
    df['NX_PDG'] = df.apply(lambda row: get_pdg_from_cpg(row.NX_CPG), axis=1)
    df = df[df.NX_PDG != '']
    # edge index of statement PDG graph
    df['graph_data'] = df.apply(lambda row: get_edge_index(row.St_Node, row.NX_PDG), axis=1)
    df = df[df.graph_data != '']
    df['NX_AST'] = df.apply(lambda row: get_ast_from_cpg(row.NX_CPG), axis=1)
    df = df[df.NX_AST != '']
    # node feature vector for each node in CPG
    df['Node_Fea_Vec'] = df.apply(lambda row: generate_node_feature_vec(row.NX_CPG, w2v_model), axis=1)
    # generate tree_info for each statement's ast-subtree
    df['tree_info'] = df.apply(lambda row: get_tree_info(row.St_Node, row.NX_AST, row.Node_Fea_Vec), axis=1)
    df = df[df.tree_info != '']
    df['graph_info'] = df.apply(
        lambda row: get_graph_info(row.St_Node, row.NX_PDG, row.NX_CPG, row.Node_Fea_Vec, row.func, row.No2St),
        axis=1)
    df = df[df.graph_info != '']
    # df['sim_input'] = df.apply(lambda row: get_sim_input(row.graph_data, row.graph_info, row.target),
    #                            axis=1)
    df['input'] = df.apply(lambda row: get_input(row.graph_data, row.graph_info, row.tree_info, row.target),
                           axis=1)
    print(df.info())
    _dataset = df.input.tolist()
    # df_target = df[['graph_data', 'tree_info', 'graph_info', 'target']]
    # _dataset =
    return _dataset





